#textdomain wesnoth-Swamplings

#define MULTI_SPEAR_SOUNDS
    [event]
        name=attacker hits
        first_time_only=no
        [filter]
            has_weapon="multi spear (arcanic)"
            #		[filter_attack]
            #			type=arcane
            #	        weapon="multi spear"
            #		[/filter_attack]
        [/filter]
        [sound]
            name=magic-missile-3.ogg
        [/sound]
    [/event]
    [event]
        name=attacker hits
        first_time_only=no
        [filter]
            has_weapon="multi spear (arctic)"
            #		[filter_attack]
            #			type=cold
            #	        weapon="multi spear"
            #		[/filter_attack]
        [/filter]
        [sound]
            name=magic-faeriefire.ogg
        [/sound]
    [/event]
    [event]
        name=attacker hits
        first_time_only=no
        [filter]
            has_weapon="multi spear (volcanic)"
            #		[filter_attack]
            #			type=fire
            #	        weapon="multi spear"
            #		[/filter_attack]
        [/filter]
        [sound]
            name=flame-big.ogg
        [/sound]
    [/event]
#enddef

# variable array of nonspeaking unit types. Necessary because some "wolves" can speak (i.e., Wolf Riders):
# TODO use this somewhere:
#define NONSPEAKING_TYPES
    [set_variable]
        name=nonspeaking_types[0].type
        value=Vampire Bat
    [/set_variable]
    [set_variable]
        name=nonspeaking_types[1].type
        value=Blood Bat
    [/set_variable]
    [set_variable]
        name=nonspeaking_types[2].type
        value=Dread Bat
    [/set_variable]
    [set_variable]
        name=nonspeaking_types[3].type
        value=Swamp Wolf
    [/set_variable]
    [set_variable]
        name=nonspeaking_types[4].type
        value=Great Wolf
    [/set_variable]
    [set_variable]
        name=nonspeaking_types[5].type
        value=Direwolf
    [/set_variable]
#enddef

# found this one in "FrankenWML":
#define GHOST_APPEAR X Y IMAGE FADE_IN_MS
    # Materializes the given image as a partially transparent, colorless ghost
    # at the given location. Uses FADE_IN_MS milliseconds per frame.
    [scroll_to]
        x,y={X},{Y}
    [/scroll_to]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.1)~GS()"
    [/item]
    [delay]
        time={FADE_IN_MS}
    [/delay]

    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.1)~GS()"
    [/remove_item]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.2)~GS()"
    [/item]
    [delay]
        time={FADE_IN_MS}
    [/delay]

    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.2)~GS()"
    [/remove_item]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.3)~GS()"
    [/item]
    [delay]
        time={FADE_IN_MS}
    [/delay]

    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.3)~GS()"
    [/remove_item]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.4)~GS()"
    [/item]
    [delay]
        time={FADE_IN_MS}
    [/delay]

    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.4)~GS()"
    [/remove_item]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.5)~GS()"
    [/item]

    [delay]
        time={FADE_IN_MS}
    [/delay]
    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.5)~GS()"
    [/remove_item]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.6)~GS()"
    [/item]
#enddef

# also from FrankenWML:
#define GHOST_FADE X Y IMAGE FADE_OUT_MS
    # Dematerializes the ghost at the given location (IMAGE must be the same as
    # for the call to GHOST_APPEAR). Uses FADE_OUT_MS milliseconds per frame.
    [scroll_to]
        x,y={X},{Y}
    [/scroll_to]
    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.6)~GS()"
    [/remove_item]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.5)~GS()"
    [/item]
    [delay]
        time={FADE_OUT_MS}
    [/delay]

    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.5)~GS()"
    [/remove_item]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.4)~GS()"
    [/item]
    [delay]
        time={FADE_OUT_MS}
    [/delay]

    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.4)~GS()"
    [/remove_item]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.3)~GS()"
    [/item]
    [delay]
        time={FADE_OUT_MS}
    [/delay]

    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.3)~GS()"
    [/remove_item]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.2)~GS()"
    [/item]
    [delay]
        time={FADE_OUT_MS}
    [/delay]

    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.2)~GS()"
    [/remove_item]
    [item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.1)~GS()"
    [/item]

    [delay]
        time={FADE_OUT_MS}
    [/delay]
    [remove_item]
        x,y={X},{Y}
        image="{IMAGE}~O(0.1)~GS()"
    [/remove_item]
#enddef

#define DIREWOLF_ADVANCEMENT
    # in latter scenarios, Goblin Knights can advance to Direwolf Riders and Great Wolves can advance to Direwolves:
    [event]
        name=post advance
        first_time_only=no

        [filter]
            type=Goblin Knight 1Sw
        [/filter]

        {MODIFY_UNIT (type=Goblin Knight 1Sw) type (Goblin Knight 2Sw)}
    [/event]
    [event]
        name=post advance
        first_time_only=no

        [filter]
            type=Great Wolf
        [/filter]

        {MODIFY_UNIT (type=Great Wolf) type (Great Wolf 2)}
    [/event]
    [event]
        name=recall
        first_time_only=no

        [filter]
            type=Goblin Knight 1Sw
        [/filter]

        {MODIFY_UNIT (type=Goblin Knight 1Sw) type (Goblin Knight 2Sw)}
    [/event]
    [event]
        name=recall
        first_time_only=no

        [filter]
            type=Wolf Rider Sw
        [/filter]

        {MODIFY_UNIT (type=Wolf Rider Sw) type (Wolf Rider 2Sw)}
    [/event]
    [event]
        name=recall
        first_time_only=no

        [filter]
            type=Great Wolf
        [/filter]

        {MODIFY_UNIT (type=Great Wolf) type (Great Wolf 2)}
    [/event]
#enddef

#define CLAMMIE_DIREWOLF_LEADER_ADVANCEMENT
    # When Clammie advances from Direwolf Rider to Direwolf Master, his leadership level increases to 4:

    [event]
        name=post advance
        first_time_only=no

        [filter]
            id=Clammie
            type=Direwolf Master
        [/filter]

        [object]
            [filter]
                id=Clammie
            [/filter]
            silent=yes
            duration=forever
            [effect]
                apply_to=remove_ability
                [abilities]
                    {ABILITY_LEADERSHIP_LEVEL_3}
                [/abilities]
            [/effect]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_LEADERSHIP_LEVEL_4}
                [/abilities]
            [/effect]
        [/object]
    [/event]
#enddef

#define MOVE_UNIT_NO_SCROLL FILTER TO_X TO_Y
    # Same as the MOVE_UNIT macro, without the annoying scroll (used in 1.8, not 1.9):
    [store_unit]
        [filter]
            {FILTER}
        [/filter]

        variable=MOVE_UNIT_temp
        kill=no
    [/store_unit]

    {VARIABLE_OP MOVE_UNIT_path_coords_x add {TO_X}}
    {VARIABLE_OP MOVE_UNIT_path_coords_y add {TO_Y}}

    [if]
        [variable]
            name=MOVE_UNIT_temp.x
            less_than={TO_X}
        [/variable]

        [then]
            {VARIABLE MOVE_UNIT_temp.facing se}
        [/then]

        [else]
            [if]
                [variable]
                    name=MOVE_UNIT_temp.x
                    greater_than={TO_X}
                [/variable]

                [then]
                    {VARIABLE MOVE_UNIT_temp.facing sw}
                [/then]
            [/if]
        [/else]
    [/if]

    {VARIABLE MOVE_UNIT_temp.x {TO_X}}
    {VARIABLE MOVE_UNIT_temp.y {TO_Y}}

    [kill]
        {FILTER}

        animate=no
        fire_event=no
    [/kill]

    [move_unit_fake]
        type=$MOVE_UNIT_temp.type
        gender=$MOVE_UNIT_temp.gender
        variation=$MOVE_UNIT_temp.variation
        side=$MOVE_UNIT_temp.side
        x=$MOVE_UNIT_path_coords_x
        y=$MOVE_UNIT_path_coords_y
    [/move_unit_fake]

    [unstore_unit]
        variable=MOVE_UNIT_temp
        find_vacant=yes
    [/unstore_unit]

    [redraw][/redraw]
    {CLEAR_VARIABLE MOVE_UNIT_temp}
    {CLEAR_VARIABLE MOVE_UNIT_path_coords_x}
    {CLEAR_VARIABLE MOVE_UNIT_path_coords_y}
#enddef

#define MISRIS_RECRUITING_FIX
    [event]
        name=recall
        [filter]
            id=Misris
        [/filter]

        {MODIFY_UNIT id=Misris overlays "misc/hero-icon.png"}
        {MODIFY_UNIT id=Misris canrecruit no}
    [/event]
#enddef

#define ANIMATED_TORCH_NE X Y
    # Embed this at scenario toplevel, not within an event.
    # Note that it will freeze while dialogue popups are onscreen.
    [terrain_graphics]
        x={X}
        y={Y}
        [tile]
            x=0
            y=0
            set_flag=torch_ne
        [/tile]
    [/terrain_graphics]
    [terrain_graphics]
        map="
, *
* , *
, 1
* , *
, *"
        [tile]
            pos=1
            has_flag=torch_ne
        [/tile]
        [image]
            # should actually be layer 0 if you wanted to walk past this wall:
            layer=1
            #            center=92,138
            #            center=92,88
            #            center=92,188
            #            center=122,158
            #            center=102,158
            #            center=97,153
            #            center=95,152
            #            center=93,151
            #            center=90,147
            # center= should probably be better at 90,145 or thereabouts, but then the torch is actually in a different hex, and vanishes. This is why we're at layer=1
            #            center=90,151
            center=90,145

            # wmlscope: start ignoring
            name="torch-ne/wall-tourch-n-ne01:140,torch-ne/wall-tourch-n-ne02:140,torch-ne/wall-tourch-n-ne03:140,torch-ne/wall-tourch-n-ne04:140,torch-ne/wall-tourch-n-ne05:140,torch-ne/wall-tourch-n-ne06:140,torch-ne/wall-tourch-n-ne07:140,torch-ne/wall-tourch-n-ne08:140,torch-ne/wall-tourch-n-ne09:140,torch-ne/wall-tourch-n-ne10:140"
            # wmlscope: stop ignoring
        [/image]
    [/terrain_graphics]
#enddef

#define ANIMATED_TORCH_NE_ZERO X Y
    # Embed this at scenario toplevel, not within an event.
    # Note that it will freeze while dialogue popups are onscreen.
    [terrain_graphics]
        x={X}
        y={Y}
        [tile]
            x=0
            y=0
            set_flag=torch_ne
        [/tile]
    [/terrain_graphics]
    [terrain_graphics]
        map="
, *
* , *
, 1
* , *
, *"
        [tile]
            pos=1
            has_flag=torch_ne
        [/tile]
        [image]
            layer=0
            #            center=92,138
            #            center=92,88
            #            center=92,188
            #            center=122,158
            #            center=102,158
            #            center=97,153
            #            center=95,152
            #            center=93,151
            #            center=90,147
            # center= should probably be better at 90,145 or thereabouts, but then the torch is actually in a different hex, and vanishes. This is why we're at layer=1
            #            center=90,151
            center=90,145

            # wmlscope: start ignoring
            name="torch-ne/wall-tourch-n-ne01:140,torch-ne/wall-tourch-n-ne02:140,torch-ne/wall-tourch-n-ne03:140,torch-ne/wall-tourch-n-ne04:140,torch-ne/wall-tourch-n-ne05:140,torch-ne/wall-tourch-n-ne06:140,torch-ne/wall-tourch-n-ne07:140,torch-ne/wall-tourch-n-ne08:140,torch-ne/wall-tourch-n-ne09:140,torch-ne/wall-tourch-n-ne10:140"
            # wmlscope: stop ignoring
        [/image]
    [/terrain_graphics]
#enddef

# current implementation of this mainline macro is bugged!
#define CLEAR_FOG_NOBUG SIDE X Y RADIUS
    # Clears fog in a specific area for the given side. This is to be used only
    # for the duration of an event: always use {UNCLEAR_FOG} (below) before the
    # event exits, or otherwise you'll be left with fake fog clearer units on
    # the map.
    [if]
        [have_unit]
            type=Fog Clearer
        [/have_unit]

        [then]
            [set_variable]
                name=fog_clearer_i
                add=1
            [/set_variable]
        [/then]

        [else]
            [set_variable]
                name=fog_clearer_i
                value=1
            [/set_variable]
        [/else]
    [/if]

    [unit]
        side={SIDE}
        type=Fog Clearer
        id=fog_clearer_$fog_clearer_i
        x,y={X},{Y}
        max_moves={RADIUS}
    [/unit]

    [store_unit]
        [filter]
            id=fog_clearer_$fog_clearer_i
        [/filter]

        kill=no
        variable=new_fog_clearer
    [/store_unit]

    [hide_unit]
        x,y=$new_fog_clearer.x,$new_fog_clearer.y
    [/hide_unit]

    [redraw]
        side={SIDE}
    [/redraw]

#enddef

#define UNCLEAR_FOG_NOBUG
    # Restores fog that was temporarily cleared (check CLEAR_FOG above). Only
    # one UNCLEAR_FOG is required no matter how many times CLEAR_FOG was used.
    [kill]
        type=Fog Clearer
        animate=no
        fire_event=no
    [/kill]

    [clear_variable]
        name=fog_clearer_i
    [/clear_variable]

    [clear_variable]
        name=new_fog_clearer
    [/clear_variable]
#enddef

#define MOVE_UNIT_BY_NO_KILL FILTER OFFSET_X OFFSET_Y
    #TODO COMMENT
    [store_unit]
        [filter]
            {FILTER}
        [/filter]

        variable=MOVE_UNIT_store
        kill=yes
    [/store_unit]

    {VARIABLE_OP MOVE_UNIT_store.x add {OFFSET_X}}
    {VARIABLE_OP MOVE_UNIT_store.y add {OFFSET_Y}}
    [unstore_unit]
        variable=MOVE_UNIT_store
        find_vacant=yes
    [/unstore_unit]
    {CLEAR_VARIABLE MOVE_UNIT_store}
#enddef
